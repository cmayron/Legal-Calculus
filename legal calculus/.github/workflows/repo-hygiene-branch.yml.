name: Repo Hygiene (branch-tuned)

on:
  workflow_dispatch:
    inputs:
      # --- Artifacts (safe) ---
      artifact_max_age_days:        { default: '30',  description: 'Delete artifacts older than this (non-expired only if allowed)' }
      artifact_delete_nonexpired:   { default: 'false', type: choice, options: ['false','true'], description: 'Also delete non-expired artifacts older than age' }
      artifact_include_names:       { default: '.*',  description: 'Regex include for artifact names' }
      artifact_exclude_names:       { default: '^$', description: 'Regex exclude for artifact names' }

      # --- Caches (on by default here) ---
      cleanup_caches:               { default: 'true', type: choice, options: ['false','true'], description: 'Enable Actions cache cleanup' }
      cache_max_age_days:           { default: '45' }
      cache_include_keys:           { default: '.*' }
      cache_exclude_keys:           { default: '^$' }

      # --- Workflow runs (keep recent; prune old) ---
      run_max_age_days:             { default: '45' }
      keep_latest_per_workflow:     { default: '30' }
      run_status:                   { default: 'completed', type: choice, options: ['completed','success','failure','cancelled','skipped'] }
      include_workflows:            { default: '.*' }
      exclude_workflows:            { default: '^$' }
      include_branches:             { default: '^(main|master|develop)$' }
      exclude_branches:             { default: '^$' }
      include_events:               { default: '.*' }
      delete_runs_with_artifacts:   { default: 'false', type: choice, options: ['false','true'] }

      # --- Safety switch ---
      dry_run:                      { default: 'true',  type: choice, options: ['true','false'], description: 'Preview only' }

  schedule:
    - cron: '23 4 * * 1'   # weekly, Mondays 04:23 UTC

permissions:
  actions: write
  contents: read

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Plan & clean
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const core = require('@actions/core');
            const owner = context.repo.owner, repo = context.repo.repo;
            const bool = s => String(s||'').toLowerCase()==='true';
            const asInt = (s,d)=>{ const n=parseInt(String(s||'').trim(),10); return Number.isFinite(n)?n:d; };
            const dAge = d => Math.floor((Date.now()-new Date(d).getTime())/86400000);
            const rx = s => { try{return new RegExp(s)}catch{return new RegExp('^$a')} };

            const cfg = {
              artMax: asInt(core.getInput('artifact_max_age_days'),30),
              artDelNonExpired: bool(core.getInput('artifact_delete_nonexpired')),
              artIn: rx(core.getInput('artifact_include_names')||'.*'),
              artEx: rx(core.getInput('artifact_exclude_names')||'^$'),

              caches: bool(core.getInput('cleanup_caches')),
              cacheMax: asInt(core.getInput('cache_max_age_days'),45),
              cacheIn: rx(core.getInput('cache_include_keys')||'.*'),
              cacheEx: rx(core.getInput('cache_exclude_keys')||'^$'),

              runMax: asInt(core.getInput('run_max_age_days'),45),
              keepLatest: asInt(core.getInput('keep_latest_per_workflow'),30),
              runStatus: core.getInput('run_status')||'completed',
              wfIn: rx(core.getInput('include_workflows')||'.*'),
              wfEx: rx(core.getInput('exclude_workflows')||'^$'),
              brIn: rx(core.getInput('include_branches')||'^(main|master|develop)$'),
              brEx: rx(core.getInput('exclude_branches')||'^$'),
              evtIn: rx(core.getInput('include_events')||'.*'),
              delRunsWithArts: bool(core.getInput('delete_runs_with_artifacts')),
              dry: bool(core.getInput('dry_run')),
            };

            const plan = { artifacts:[], runs:[], caches:[] };

            // ---- Artifacts
            const arts = await github.paginate('GET /repos/{owner}/{repo}/actions/artifacts', {owner, repo, per_page:100});
            for(const a of arts){
              const nameOK = cfg.artIn.test(a.name) && !cfg.artEx.test(a.name);
              const age = dAge(a.created_at);
              const expired = a.expired || (a.expires_at ? new Date(a.expires_at) < new Date() : false);
              const eligible = expired || (cfg.artDelNonExpired && age > cfg.artMax);
              if(nameOK && eligible) plan.artifacts.push({id:a.id,name:a.name,age,expired});
            }

            // ---- Runs (grouped by workflow, keep newest N, prune older + aged)
            const runs = await github.paginate('GET /repos/{owner}/{repo}/actions/runs', {owner, repo, per_page:100, status: cfg.runStatus});
            const byWf = new Map();
            for(const r of runs){
              if(!cfg.wfIn.test(r.name||'') || cfg.wfEx.test(r.name||'')) continue;
              if(!cfg.brIn.test(r.head_branch||'') || cfg.brEx.test(r.head_branch||'')) continue;
              if(!cfg.evtIn.test(r.event||'')) continue;
              if(!byWf.has(r.workflow_id)) byWf.set(r.workflow_id, []);
              byWf.get(r.workflow_id).push(r);
            }
            for(const arr of byWf.values()){
              arr.sort((a,b)=> new Date(b.created_at) - new Date(a.created_at));
              for(const r of arr.slice(cfg.keepLatest)){
                const age = dAge(r.created_at);
                if(age <= cfg.runMax) continue;

                // Skip runs with artifacts unless allowed
                let hasArts = false;
                try{
                  const res = await github.request('GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts',
                    {owner, repo, run_id:r.id, per_page:1});
                  hasArts = (res.data.total_count||0) > 0;
                }catch{}
                if(hasArts && !cfg.delRunsWithArts) continue;

                plan.runs.push({id:r.id,name:r.name,age,status:r.status,conclusion:r.conclusion,event:r.event,branch:r.head_branch,hasArtifacts:hasArts});
              }
            }

            // ---- Caches (enabled by default here)
            if(cfg.caches){
              const caches = await github.paginate('GET /repos/{owner}/{repo}/actions/caches', {owner, repo, per_page:100});
              for(const c of caches){
                const keyOK = cfg.cacheIn.test(c.key) && !cfg.cacheEx.test(c.key);
                const age = dAge(c.last_accessed_at || c.created_at);
                if(keyOK && age > cfg.cacheMax) plan.caches.push({id:c.id,key:c.key,age});
              }
            }

            // ---- Execute (or DRY RUN)
            const act = async (msg, fn) => cfg.dry ? core.notice('[PLAN] '+msg) : (await fn(), core.notice('[DONE] '+msg));
            for(const a of plan.artifacts){ await act(`[artifact] #${a.id} "${a.name}" age=${a.age}d expired=${a.expired}`,
              ()=> github.request('DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}', {owner, repo, artifact_id:a.id}) ); }
            for(const r of plan.runs){ await act(`[run] #${r.id} "${r.name}" age=${r.age}d ${r.status}/${r.conclusion} event=${r.event} branch=${r.branch} artifacts=${r.hasArtifacts}`,
              ()=> github.request('DELETE /repos/{owner}/{repo}/actions/runs/{run_id}', {owner, repo, run_id:r.id}) ); }
            for(const c of plan.caches){
              await act(`[cache] id=${c.id} key="${c.key}" age=${c.age}d`,
                async ()=> {
                  try{ await github.request('DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}', {owner, repo, cache_id:c.id}); }
                  catch{ await github.request('DELETE /repos/{owner}/{repo}/actions/caches', {owner, repo, key:c.key}); }
                }
              );
            }

            core.summary
              .addHeading('Repo Hygiene Summary')
              .addTable([
                [{data:'Artifacts',header:true},{data:String(plan.artifacts.length)}],
                [{data:'Runs',header:true},{data:String(plan.runs.length)}],
                [{data:'Caches',header:true},{data:String(plan.caches.length)}],
                [{data:'Dry-Run',header:true},{data:String(cfg.dry)}],
              ])
              .write();